input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type CleanBeauty {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Organic(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Vegan(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type CleanBeautyConnection {
  values: [CleanBeauty]
  groupBy: CleanBeautyGroupBy
  aggregate: CleanBeautyAggregator
}

type CleanBeautyAggregator {
  count: Int
  totalCount: Int
}

type CleanBeautyGroupBy {
  id: [CleanBeautyConnectionId]
  created_at: [CleanBeautyConnectionCreated_at]
  updated_at: [CleanBeautyConnectionUpdated_at]
  published_at: [CleanBeautyConnectionPublished_at]
}

type CleanBeautyConnectionId {
  key: ID
  connection: CleanBeautyConnection
}

type CleanBeautyConnectionCreated_at {
  key: DateTime
  connection: CleanBeautyConnection
}

type CleanBeautyConnectionUpdated_at {
  key: DateTime
  connection: CleanBeautyConnection
}

type CleanBeautyConnectionPublished_at {
  key: DateTime
  connection: CleanBeautyConnection
}

input CleanBeautyInput {
  Organic: [ID]
  Vegan: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editCleanBeautyInput {
  Organic: [ID]
  Vegan: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createCleanBeautyInput {
  data: CleanBeautyInput
}

type createCleanBeautyPayload {
  cleanBeauty: CleanBeauty
}

input updateCleanBeautyInput {
  where: InputID
  data: editCleanBeautyInput
}

type updateCleanBeautyPayload {
  cleanBeauty: CleanBeauty
}

input deleteCleanBeautyInput {
  where: InputID
}

type deleteCleanBeautyPayload {
  cleanBeauty: CleanBeauty
}

type Discount {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  discount: Float
  minprice: Float
  published_at: DateTime
}

input DiscountInput {
  discount: Float
  minprice: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDiscountInput {
  discount: Float
  minprice: Float
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input updateDiscountInput {
  data: editDiscountInput
}

type updateDiscountPayload {
  discount: Discount
}

type deleteDiscountPayload {
  discount: Discount
}

type FavoriteProduct {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  product: Products
  published_at: DateTime
}

type FavoriteProductConnection {
  values: [FavoriteProduct]
  groupBy: FavoriteProductGroupBy
  aggregate: FavoriteProductAggregator
}

type FavoriteProductAggregator {
  count: Int
  totalCount: Int
}

type FavoriteProductGroupBy {
  id: [FavoriteProductConnectionId]
  created_at: [FavoriteProductConnectionCreated_at]
  updated_at: [FavoriteProductConnectionUpdated_at]
  users_permissions_user: [FavoriteProductConnectionUsers_permissions_user]
  product: [FavoriteProductConnectionProduct]
  published_at: [FavoriteProductConnectionPublished_at]
}

type FavoriteProductConnectionId {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionCreated_at {
  key: DateTime
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionUpdated_at {
  key: DateTime
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionUsers_permissions_user {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionProduct {
  key: ID
  connection: FavoriteProductConnection
}

type FavoriteProductConnectionPublished_at {
  key: DateTime
  connection: FavoriteProductConnection
}

input FavoriteProductInput {
  users_permissions_user: ID
  product: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editFavoriteProductInput {
  users_permissions_user: ID
  product: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createFavoriteProductInput {
  data: FavoriteProductInput
}

type createFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

input updateFavoriteProductInput {
  where: InputID
  data: editFavoriteProductInput
}

type updateFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

input deleteFavoriteProductInput {
  where: InputID
}

type deleteFavoriteProductPayload {
  favoriteProduct: FavoriteProduct
}

type Gesicht {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  gesichtsreinigung: Gesichtsreinigung
  gesichtspflege: Gesichtspflege
  Hautbedurfnis: Hautbedurfnis
  published_at: DateTime
  Tagespflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Nachtpflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Wirkstoffe(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Essenzen_Booster(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Sonnenschutz(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type GesichtConnection {
  values: [Gesicht]
  groupBy: GesichtGroupBy
  aggregate: GesichtAggregator
}

type GesichtAggregator {
  count: Int
  totalCount: Int
}

type GesichtGroupBy {
  id: [GesichtConnectionId]
  created_at: [GesichtConnectionCreated_at]
  updated_at: [GesichtConnectionUpdated_at]
  gesichtsreinigung: [GesichtConnectionGesichtsreinigung]
  gesichtspflege: [GesichtConnectionGesichtspflege]
  Hautbedurfnis: [GesichtConnectionHautbedurfnis]
  published_at: [GesichtConnectionPublished_at]
}

type GesichtConnectionId {
  key: ID
  connection: GesichtConnection
}

type GesichtConnectionCreated_at {
  key: DateTime
  connection: GesichtConnection
}

type GesichtConnectionUpdated_at {
  key: DateTime
  connection: GesichtConnection
}

type GesichtConnectionGesichtsreinigung {
  key: ID
  connection: GesichtConnection
}

type GesichtConnectionGesichtspflege {
  key: ID
  connection: GesichtConnection
}

type GesichtConnectionHautbedurfnis {
  key: ID
  connection: GesichtConnection
}

type GesichtConnectionPublished_at {
  key: DateTime
  connection: GesichtConnection
}

input GesichtInput {
  Tagespflege: [ID]
  Nachtpflege: [ID]
  gesichtsreinigung: ID
  gesichtspflege: ID
  Wirkstoffe: [ID]
  Essenzen_Booster: [ID]
  Sonnenschutz: [ID]
  Hautbedurfnis: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editGesichtInput {
  Tagespflege: [ID]
  Nachtpflege: [ID]
  gesichtsreinigung: ID
  gesichtspflege: ID
  Wirkstoffe: [ID]
  Essenzen_Booster: [ID]
  Sonnenschutz: [ID]
  Hautbedurfnis: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createGesichtInput {
  data: GesichtInput
}

type createGesichtPayload {
  gesicht: Gesicht
}

input updateGesichtInput {
  where: InputID
  data: editGesichtInput
}

type updateGesichtPayload {
  gesicht: Gesicht
}

input deleteGesichtInput {
  where: InputID
}

type deleteGesichtPayload {
  gesicht: Gesicht
}

type Gesichtspflege {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Gesichtsol(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Gesichtsserum(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Gesichtsspray(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Masken(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Augenpflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Halspflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Lippenpflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Zahnpflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type GesichtspflegeConnection {
  values: [Gesichtspflege]
  groupBy: GesichtspflegeGroupBy
  aggregate: GesichtspflegeAggregator
}

type GesichtspflegeAggregator {
  count: Int
  totalCount: Int
}

type GesichtspflegeGroupBy {
  id: [GesichtspflegeConnectionId]
  created_at: [GesichtspflegeConnectionCreated_at]
  updated_at: [GesichtspflegeConnectionUpdated_at]
  published_at: [GesichtspflegeConnectionPublished_at]
}

type GesichtspflegeConnectionId {
  key: ID
  connection: GesichtspflegeConnection
}

type GesichtspflegeConnectionCreated_at {
  key: DateTime
  connection: GesichtspflegeConnection
}

type GesichtspflegeConnectionUpdated_at {
  key: DateTime
  connection: GesichtspflegeConnection
}

type GesichtspflegeConnectionPublished_at {
  key: DateTime
  connection: GesichtspflegeConnection
}

input GesichtspflegeInput {
  Gesichtsol: [ID]
  Gesichtsserum: [ID]
  Gesichtsspray: [ID]
  Masken: [ID]
  Augenpflege: [ID]
  Halspflege: [ID]
  Lippenpflege: [ID]
  Zahnpflege: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editGesichtspflegeInput {
  Gesichtsol: [ID]
  Gesichtsserum: [ID]
  Gesichtsspray: [ID]
  Masken: [ID]
  Augenpflege: [ID]
  Halspflege: [ID]
  Lippenpflege: [ID]
  Zahnpflege: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createGesichtspflegeInput {
  data: GesichtspflegeInput
}

type createGesichtspflegePayload {
  gesichtspflege: Gesichtspflege
}

input updateGesichtspflegeInput {
  where: InputID
  data: editGesichtspflegeInput
}

type updateGesichtspflegePayload {
  gesichtspflege: Gesichtspflege
}

input deleteGesichtspflegeInput {
  where: InputID
}

type deleteGesichtspflegePayload {
  gesichtspflege: Gesichtspflege
}

type Gesichtsreinigung {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Gesichtswasser(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Peeling(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type GesichtsreinigungConnection {
  values: [Gesichtsreinigung]
  groupBy: GesichtsreinigungGroupBy
  aggregate: GesichtsreinigungAggregator
}

type GesichtsreinigungAggregator {
  count: Int
  totalCount: Int
}

type GesichtsreinigungGroupBy {
  id: [GesichtsreinigungConnectionId]
  created_at: [GesichtsreinigungConnectionCreated_at]
  updated_at: [GesichtsreinigungConnectionUpdated_at]
  published_at: [GesichtsreinigungConnectionPublished_at]
}

type GesichtsreinigungConnectionId {
  key: ID
  connection: GesichtsreinigungConnection
}

type GesichtsreinigungConnectionCreated_at {
  key: DateTime
  connection: GesichtsreinigungConnection
}

type GesichtsreinigungConnectionUpdated_at {
  key: DateTime
  connection: GesichtsreinigungConnection
}

type GesichtsreinigungConnectionPublished_at {
  key: DateTime
  connection: GesichtsreinigungConnection
}

input GesichtsreinigungInput {
  Gesichtswasser: [ID]
  Peeling: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editGesichtsreinigungInput {
  Gesichtswasser: [ID]
  Peeling: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createGesichtsreinigungInput {
  data: GesichtsreinigungInput
}

type createGesichtsreinigungPayload {
  gesichtsreinigung: Gesichtsreinigung
}

input updateGesichtsreinigungInput {
  where: InputID
  data: editGesichtsreinigungInput
}

type updateGesichtsreinigungPayload {
  gesichtsreinigung: Gesichtsreinigung
}

input deleteGesichtsreinigungInput {
  where: InputID
}

type deleteGesichtsreinigungPayload {
  gesichtsreinigung: Gesichtsreinigung
}

type Haarbedurfnis {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Loremipsum(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type HaarbedurfnisConnection {
  values: [Haarbedurfnis]
  groupBy: HaarbedurfnisGroupBy
  aggregate: HaarbedurfnisAggregator
}

type HaarbedurfnisAggregator {
  count: Int
  totalCount: Int
}

type HaarbedurfnisGroupBy {
  id: [HaarbedurfnisConnectionId]
  created_at: [HaarbedurfnisConnectionCreated_at]
  updated_at: [HaarbedurfnisConnectionUpdated_at]
  published_at: [HaarbedurfnisConnectionPublished_at]
}

type HaarbedurfnisConnectionId {
  key: ID
  connection: HaarbedurfnisConnection
}

type HaarbedurfnisConnectionCreated_at {
  key: DateTime
  connection: HaarbedurfnisConnection
}

type HaarbedurfnisConnectionUpdated_at {
  key: DateTime
  connection: HaarbedurfnisConnection
}

type HaarbedurfnisConnectionPublished_at {
  key: DateTime
  connection: HaarbedurfnisConnection
}

input HaarbedurfniInput {
  Loremipsum: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHaarbedurfniInput {
  Loremipsum: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createHaarbedurfniInput {
  data: HaarbedurfniInput
}

type createHaarbedurfniPayload {
  haarbedurfni: Haarbedurfnis
}

input updateHaarbedurfniInput {
  where: InputID
  data: editHaarbedurfniInput
}

type updateHaarbedurfniPayload {
  haarbedurfni: Haarbedurfnis
}

input deleteHaarbedurfniInput {
  where: InputID
}

type deleteHaarbedurfniPayload {
  haarbedurfni: Haarbedurfnis
}

type Haare {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  shampoo_conditioner: ShampooConditioner
  intensivpflege: Intensivpflege
  styling: Styling
  haarbedurfni: Haarbedurfnis
  spezialpflege: Spezialpflege
  published_at: DateTime
}

type HaareConnection {
  values: [Haare]
  groupBy: HaareGroupBy
  aggregate: HaareAggregator
}

type HaareAggregator {
  count: Int
  totalCount: Int
}

type HaareGroupBy {
  id: [HaareConnectionId]
  created_at: [HaareConnectionCreated_at]
  updated_at: [HaareConnectionUpdated_at]
  shampoo_conditioner: [HaareConnectionShampoo_conditioner]
  intensivpflege: [HaareConnectionIntensivpflege]
  styling: [HaareConnectionStyling]
  haarbedurfni: [HaareConnectionHaarbedurfni]
  spezialpflege: [HaareConnectionSpezialpflege]
  published_at: [HaareConnectionPublished_at]
}

type HaareConnectionId {
  key: ID
  connection: HaareConnection
}

type HaareConnectionCreated_at {
  key: DateTime
  connection: HaareConnection
}

type HaareConnectionUpdated_at {
  key: DateTime
  connection: HaareConnection
}

type HaareConnectionShampoo_conditioner {
  key: ID
  connection: HaareConnection
}

type HaareConnectionIntensivpflege {
  key: ID
  connection: HaareConnection
}

type HaareConnectionStyling {
  key: ID
  connection: HaareConnection
}

type HaareConnectionHaarbedurfni {
  key: ID
  connection: HaareConnection
}

type HaareConnectionSpezialpflege {
  key: ID
  connection: HaareConnection
}

type HaareConnectionPublished_at {
  key: DateTime
  connection: HaareConnection
}

input HaareInput {
  shampoo_conditioner: ID
  intensivpflege: ID
  styling: ID
  haarbedurfni: ID
  spezialpflege: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHaareInput {
  shampoo_conditioner: ID
  intensivpflege: ID
  styling: ID
  haarbedurfni: ID
  spezialpflege: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createHaareInput {
  data: HaareInput
}

type createHaarePayload {
  haare: Haare
}

input updateHaareInput {
  where: InputID
  data: editHaareInput
}

type updateHaarePayload {
  haare: Haare
}

input deleteHaareInput {
  where: InputID
}

type deleteHaarePayload {
  haare: Haare
}

type HandeFusse {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Fubpflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Handpflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type HandeFusseConnection {
  values: [HandeFusse]
  groupBy: HandeFusseGroupBy
  aggregate: HandeFusseAggregator
}

type HandeFusseAggregator {
  count: Int
  totalCount: Int
}

type HandeFusseGroupBy {
  id: [HandeFusseConnectionId]
  created_at: [HandeFusseConnectionCreated_at]
  updated_at: [HandeFusseConnectionUpdated_at]
  published_at: [HandeFusseConnectionPublished_at]
}

type HandeFusseConnectionId {
  key: ID
  connection: HandeFusseConnection
}

type HandeFusseConnectionCreated_at {
  key: DateTime
  connection: HandeFusseConnection
}

type HandeFusseConnectionUpdated_at {
  key: DateTime
  connection: HandeFusseConnection
}

type HandeFusseConnectionPublished_at {
  key: DateTime
  connection: HandeFusseConnection
}

input HandeFusseInput {
  Fubpflege: [ID]
  Handpflege: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHandeFusseInput {
  Fubpflege: [ID]
  Handpflege: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createHandeFusseInput {
  data: HandeFusseInput
}

type createHandeFussePayload {
  handeFusse: HandeFusse
}

input updateHandeFusseInput {
  where: InputID
  data: editHandeFusseInput
}

type updateHandeFussePayload {
  handeFusse: HandeFusse
}

input deleteHandeFusseInput {
  where: InputID
}

type deleteHandeFussePayload {
  handeFusse: HandeFusse
}

type Hautbedurfnis {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Hautprobleme(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type HautbedurfnisConnection {
  values: [Hautbedurfnis]
  groupBy: HautbedurfnisGroupBy
  aggregate: HautbedurfnisAggregator
}

type HautbedurfnisAggregator {
  count: Int
  totalCount: Int
}

type HautbedurfnisGroupBy {
  id: [HautbedurfnisConnectionId]
  created_at: [HautbedurfnisConnectionCreated_at]
  updated_at: [HautbedurfnisConnectionUpdated_at]
  published_at: [HautbedurfnisConnectionPublished_at]
}

type HautbedurfnisConnectionId {
  key: ID
  connection: HautbedurfnisConnection
}

type HautbedurfnisConnectionCreated_at {
  key: DateTime
  connection: HautbedurfnisConnection
}

type HautbedurfnisConnectionUpdated_at {
  key: DateTime
  connection: HautbedurfnisConnection
}

type HautbedurfnisConnectionPublished_at {
  key: DateTime
  connection: HautbedurfnisConnection
}

input HautbedurfniInput {
  Hautprobleme: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHautbedurfniInput {
  Hautprobleme: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createHautbedurfniInput {
  data: HautbedurfniInput
}

type createHautbedurfniPayload {
  hautbedurfni: Hautbedurfnis
}

input updateHautbedurfniInput {
  where: InputID
  data: editHautbedurfniInput
}

type updateHautbedurfniPayload {
  hautbedurfni: Hautbedurfnis
}

input deleteHautbedurfniInput {
  where: InputID
}

type deleteHautbedurfniPayload {
  hautbedurfni: Hautbedurfnis
}

type Herren {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Dufte(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Rasur(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Bart(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Pflege(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type HerrenConnection {
  values: [Herren]
  groupBy: HerrenGroupBy
  aggregate: HerrenAggregator
}

type HerrenAggregator {
  count: Int
  totalCount: Int
}

type HerrenGroupBy {
  id: [HerrenConnectionId]
  created_at: [HerrenConnectionCreated_at]
  updated_at: [HerrenConnectionUpdated_at]
  published_at: [HerrenConnectionPublished_at]
}

type HerrenConnectionId {
  key: ID
  connection: HerrenConnection
}

type HerrenConnectionCreated_at {
  key: DateTime
  connection: HerrenConnection
}

type HerrenConnectionUpdated_at {
  key: DateTime
  connection: HerrenConnection
}

type HerrenConnectionPublished_at {
  key: DateTime
  connection: HerrenConnection
}

input HerrenInput {
  Dufte: [ID]
  Rasur: [ID]
  Bart: [ID]
  Pflege: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHerrenInput {
  Dufte: [ID]
  Rasur: [ID]
  Bart: [ID]
  Pflege: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createHerrenInput {
  data: HerrenInput
}

type createHerrenPayload {
  herren: Herren
}

input updateHerrenInput {
  where: InputID
  data: editHerrenInput
}

type updateHerrenPayload {
  herren: Herren
}

input deleteHerrenInput {
  where: InputID
}

type deleteHerrenPayload {
  herren: Herren
}

type HomePageAdvertising {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  Name: String
  Description: String
  Advertising: String
  onImageAdvertising: String
  onImageText: String
  published_at: DateTime
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type HomePageAdvertisingConnection {
  values: [HomePageAdvertising]
  groupBy: HomePageAdvertisingGroupBy
  aggregate: HomePageAdvertisingAggregator
}

type HomePageAdvertisingAggregator {
  count: Int
  totalCount: Int
}

type HomePageAdvertisingGroupBy {
  id: [HomePageAdvertisingConnectionId]
  created_at: [HomePageAdvertisingConnectionCreated_at]
  updated_at: [HomePageAdvertisingConnectionUpdated_at]
  Name: [HomePageAdvertisingConnectionName]
  Description: [HomePageAdvertisingConnectionDescription]
  Advertising: [HomePageAdvertisingConnectionAdvertising]
  onImageAdvertising: [HomePageAdvertisingConnectionOnImageAdvertising]
  onImageText: [HomePageAdvertisingConnectionOnImageText]
  published_at: [HomePageAdvertisingConnectionPublished_at]
}

type HomePageAdvertisingConnectionId {
  key: ID
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionCreated_at {
  key: DateTime
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionUpdated_at {
  key: DateTime
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionName {
  key: String
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionDescription {
  key: String
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionAdvertising {
  key: String
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionOnImageAdvertising {
  key: String
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionOnImageText {
  key: String
  connection: HomePageAdvertisingConnection
}

type HomePageAdvertisingConnectionPublished_at {
  key: DateTime
  connection: HomePageAdvertisingConnection
}

input HomePageAdvertisingInput {
  Name: String
  Description: String
  Advertising: String
  images: [ID]
  onImageAdvertising: String
  onImageText: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editHomePageAdvertisingInput {
  Name: String
  Description: String
  Advertising: String
  images: [ID]
  onImageAdvertising: String
  onImageText: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createHomePageAdvertisingInput {
  data: HomePageAdvertisingInput
}

type createHomePageAdvertisingPayload {
  homePageAdvertising: HomePageAdvertising
}

input updateHomePageAdvertisingInput {
  where: InputID
  data: editHomePageAdvertisingInput
}

type updateHomePageAdvertisingPayload {
  homePageAdvertising: HomePageAdvertising
}

input deleteHomePageAdvertisingInput {
  where: InputID
}

type deleteHomePageAdvertisingPayload {
  homePageAdvertising: HomePageAdvertising
}

type Intensivpflege {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Haarmaske(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Haarol(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type IntensivpflegeConnection {
  values: [Intensivpflege]
  groupBy: IntensivpflegeGroupBy
  aggregate: IntensivpflegeAggregator
}

type IntensivpflegeAggregator {
  count: Int
  totalCount: Int
}

type IntensivpflegeGroupBy {
  id: [IntensivpflegeConnectionId]
  created_at: [IntensivpflegeConnectionCreated_at]
  updated_at: [IntensivpflegeConnectionUpdated_at]
  published_at: [IntensivpflegeConnectionPublished_at]
}

type IntensivpflegeConnectionId {
  key: ID
  connection: IntensivpflegeConnection
}

type IntensivpflegeConnectionCreated_at {
  key: DateTime
  connection: IntensivpflegeConnection
}

type IntensivpflegeConnectionUpdated_at {
  key: DateTime
  connection: IntensivpflegeConnection
}

type IntensivpflegeConnectionPublished_at {
  key: DateTime
  connection: IntensivpflegeConnection
}

input IntensivpflegeInput {
  Haarmaske: [ID]
  Haarol: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editIntensivpflegeInput {
  Haarmaske: [ID]
  Haarol: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createIntensivpflegeInput {
  data: IntensivpflegeInput
}

type createIntensivpflegePayload {
  intensivpflege: Intensivpflege
}

input updateIntensivpflegeInput {
  where: InputID
  data: editIntensivpflegeInput
}

type updateIntensivpflegePayload {
  intensivpflege: Intensivpflege
}

input deleteIntensivpflegeInput {
  where: InputID
}

type deleteIntensivpflegePayload {
  intensivpflege: Intensivpflege
}

type Korper {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  reinigung: Reinigung
  korperpflege: Korperpflege
  hande_fusse: HandeFusse
  published_at: DateTime
  Sonnenschutz(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type KorperConnection {
  values: [Korper]
  groupBy: KorperGroupBy
  aggregate: KorperAggregator
}

type KorperAggregator {
  count: Int
  totalCount: Int
}

type KorperGroupBy {
  id: [KorperConnectionId]
  created_at: [KorperConnectionCreated_at]
  updated_at: [KorperConnectionUpdated_at]
  reinigung: [KorperConnectionReinigung]
  korperpflege: [KorperConnectionKorperpflege]
  hande_fusse: [KorperConnectionHande_fusse]
  published_at: [KorperConnectionPublished_at]
}

type KorperConnectionId {
  key: ID
  connection: KorperConnection
}

type KorperConnectionCreated_at {
  key: DateTime
  connection: KorperConnection
}

type KorperConnectionUpdated_at {
  key: DateTime
  connection: KorperConnection
}

type KorperConnectionReinigung {
  key: ID
  connection: KorperConnection
}

type KorperConnectionKorperpflege {
  key: ID
  connection: KorperConnection
}

type KorperConnectionHande_fusse {
  key: ID
  connection: KorperConnection
}

type KorperConnectionPublished_at {
  key: DateTime
  connection: KorperConnection
}

input KorperInput {
  reinigung: ID
  korperpflege: ID
  hande_fusse: ID
  Sonnenschutz: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editKorperInput {
  reinigung: ID
  korperpflege: ID
  hande_fusse: ID
  Sonnenschutz: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createKorperInput {
  data: KorperInput
}

type createKorperPayload {
  korper: Korper
}

input updateKorperInput {
  where: InputID
  data: editKorperInput
}

type updateKorperPayload {
  korper: Korper
}

input deleteKorperInput {
  where: InputID
}

type deleteKorperPayload {
  korper: Korper
}

type Korperpflege {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  BodyButter(sort: String, limit: Int, start: Int, where: JSON): [Products]
  BodyOil(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Deodorant(sort: String, limit: Int, start: Int, where: JSON): [Products]
  DuschenBaden(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Peeling(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Pflegen(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type KorperpflegeConnection {
  values: [Korperpflege]
  groupBy: KorperpflegeGroupBy
  aggregate: KorperpflegeAggregator
}

type KorperpflegeAggregator {
  count: Int
  totalCount: Int
}

type KorperpflegeGroupBy {
  id: [KorperpflegeConnectionId]
  created_at: [KorperpflegeConnectionCreated_at]
  updated_at: [KorperpflegeConnectionUpdated_at]
  published_at: [KorperpflegeConnectionPublished_at]
}

type KorperpflegeConnectionId {
  key: ID
  connection: KorperpflegeConnection
}

type KorperpflegeConnectionCreated_at {
  key: DateTime
  connection: KorperpflegeConnection
}

type KorperpflegeConnectionUpdated_at {
  key: DateTime
  connection: KorperpflegeConnection
}

type KorperpflegeConnectionPublished_at {
  key: DateTime
  connection: KorperpflegeConnection
}

input KorperpflegeInput {
  BodyButter: [ID]
  BodyOil: [ID]
  Deodorant: [ID]
  DuschenBaden: [ID]
  Peeling: [ID]
  Pflegen: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editKorperpflegeInput {
  BodyButter: [ID]
  BodyOil: [ID]
  Deodorant: [ID]
  DuschenBaden: [ID]
  Peeling: [ID]
  Pflegen: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createKorperpflegeInput {
  data: KorperpflegeInput
}

type createKorperpflegePayload {
  korperpflege: Korperpflege
}

input updateKorperpflegeInput {
  where: InputID
  data: editKorperpflegeInput
}

type updateKorperpflegePayload {
  korperpflege: Korperpflege
}

input deleteKorperpflegeInput {
  where: InputID
}

type deleteKorperpflegePayload {
  korperpflege: Korperpflege
}

type Livestyle {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Trinkflaschen(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Makeup_Etuis(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Korperbursten(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Kerzen(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Fur_Mutter(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Nahrungserganzungsmittel(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type LivestyleConnection {
  values: [Livestyle]
  groupBy: LivestyleGroupBy
  aggregate: LivestyleAggregator
}

type LivestyleAggregator {
  count: Int
  totalCount: Int
}

type LivestyleGroupBy {
  id: [LivestyleConnectionId]
  created_at: [LivestyleConnectionCreated_at]
  updated_at: [LivestyleConnectionUpdated_at]
  published_at: [LivestyleConnectionPublished_at]
}

type LivestyleConnectionId {
  key: ID
  connection: LivestyleConnection
}

type LivestyleConnectionCreated_at {
  key: DateTime
  connection: LivestyleConnection
}

type LivestyleConnectionUpdated_at {
  key: DateTime
  connection: LivestyleConnection
}

type LivestyleConnectionPublished_at {
  key: DateTime
  connection: LivestyleConnection
}

input LivestyleInput {
  Trinkflaschen: [ID]
  Makeup_Etuis: [ID]
  Korperbursten: [ID]
  Kerzen: [ID]
  Fur_Mutter: [ID]
  Nahrungserganzungsmittel: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editLivestyleInput {
  Trinkflaschen: [ID]
  Makeup_Etuis: [ID]
  Korperbursten: [ID]
  Kerzen: [ID]
  Fur_Mutter: [ID]
  Nahrungserganzungsmittel: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createLivestyleInput {
  data: LivestyleInput
}

type createLivestylePayload {
  livestyle: Livestyle
}

input updateLivestyleInput {
  where: InputID
  data: editLivestyleInput
}

type updateLivestylePayload {
  livestyle: Livestyle
}

input deleteLivestyleInput {
  where: InputID
}

type deleteLivestylePayload {
  livestyle: Livestyle
}

type Navbar {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  categories: JSON
  published_at: DateTime
}

type NavbarConnection {
  values: [Navbar]
  groupBy: NavbarGroupBy
  aggregate: NavbarAggregator
}

type NavbarAggregator {
  count: Int
  totalCount: Int
}

type NavbarGroupBy {
  id: [NavbarConnectionId]
  created_at: [NavbarConnectionCreated_at]
  updated_at: [NavbarConnectionUpdated_at]
  categories: [NavbarConnectionCategories]
  published_at: [NavbarConnectionPublished_at]
}

type NavbarConnectionId {
  key: ID
  connection: NavbarConnection
}

type NavbarConnectionCreated_at {
  key: DateTime
  connection: NavbarConnection
}

type NavbarConnectionUpdated_at {
  key: DateTime
  connection: NavbarConnection
}

type NavbarConnectionCategories {
  key: JSON
  connection: NavbarConnection
}

type NavbarConnectionPublished_at {
  key: DateTime
  connection: NavbarConnection
}

input NavbarInput {
  categories: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editNavbarInput {
  categories: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createNavbarInput {
  data: NavbarInput
}

type createNavbarPayload {
  navbar: Navbar
}

input updateNavbarInput {
  where: InputID
  data: editNavbarInput
}

type updateNavbarPayload {
  navbar: Navbar
}

input deleteNavbarInput {
  where: InputID
}

type deleteNavbarPayload {
  navbar: Navbar
}

type PageHeader {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  info: String
  page_headers_style: JSON
  published_at: DateTime
}

type PageHeaderConnection {
  values: [PageHeader]
  groupBy: PageHeaderGroupBy
  aggregate: PageHeaderAggregator
}

type PageHeaderAggregator {
  count: Int
  totalCount: Int
}

type PageHeaderGroupBy {
  id: [PageHeaderConnectionId]
  created_at: [PageHeaderConnectionCreated_at]
  updated_at: [PageHeaderConnectionUpdated_at]
  info: [PageHeaderConnectionInfo]
  page_headers_style: [PageHeaderConnectionPage_headers_style]
  published_at: [PageHeaderConnectionPublished_at]
}

type PageHeaderConnectionId {
  key: ID
  connection: PageHeaderConnection
}

type PageHeaderConnectionCreated_at {
  key: DateTime
  connection: PageHeaderConnection
}

type PageHeaderConnectionUpdated_at {
  key: DateTime
  connection: PageHeaderConnection
}

type PageHeaderConnectionInfo {
  key: String
  connection: PageHeaderConnection
}

type PageHeaderConnectionPage_headers_style {
  key: JSON
  connection: PageHeaderConnection
}

type PageHeaderConnectionPublished_at {
  key: DateTime
  connection: PageHeaderConnection
}

input PageHeaderInput {
  info: String
  page_headers_style: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editPageHeaderInput {
  info: String
  page_headers_style: JSON
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createPageHeaderInput {
  data: PageHeaderInput
}

type createPageHeaderPayload {
  pageHeader: PageHeader
}

input updatePageHeaderInput {
  where: InputID
  data: editPageHeaderInput
}

type updatePageHeaderPayload {
  pageHeader: PageHeader
}

input deletePageHeaderInput {
  where: InputID
}

type deletePageHeaderPayload {
  pageHeader: PageHeader
}

type Parfums {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Damen(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Herren(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Unisex(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type ParfumsConnection {
  values: [Parfums]
  groupBy: ParfumsGroupBy
  aggregate: ParfumsAggregator
}

type ParfumsAggregator {
  count: Int
  totalCount: Int
}

type ParfumsGroupBy {
  id: [ParfumsConnectionId]
  created_at: [ParfumsConnectionCreated_at]
  updated_at: [ParfumsConnectionUpdated_at]
  published_at: [ParfumsConnectionPublished_at]
}

type ParfumsConnectionId {
  key: ID
  connection: ParfumsConnection
}

type ParfumsConnectionCreated_at {
  key: DateTime
  connection: ParfumsConnection
}

type ParfumsConnectionUpdated_at {
  key: DateTime
  connection: ParfumsConnection
}

type ParfumsConnectionPublished_at {
  key: DateTime
  connection: ParfumsConnection
}

input ParfumInput {
  Damen: [ID]
  Herren: [ID]
  Unisex: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editParfumInput {
  Damen: [ID]
  Herren: [ID]
  Unisex: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createParfumInput {
  data: ParfumInput
}

type createParfumPayload {
  parfum: Parfums
}

input updateParfumInput {
  where: InputID
  data: editParfumInput
}

type updateParfumPayload {
  parfum: Parfums
}

input deleteParfumInput {
  where: InputID
}

type deleteParfumPayload {
  parfum: Parfums
}

type Products {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  price: String
  images: UploadFile
  clean_product: Boolean
  company: String
  energy_kapseln: Boolean
  kapseln: Boolean
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: TypeTest
  published_at: DateTime
}

type ProductsConnection {
  values: [Products]
  groupBy: ProductsGroupBy
  aggregate: ProductsAggregator
}

type ProductsAggregator {
  count: Int
  totalCount: Int
}

type ProductsGroupBy {
  id: [ProductsConnectionId]
  created_at: [ProductsConnectionCreated_at]
  updated_at: [ProductsConnectionUpdated_at]
  price: [ProductsConnectionPrice]
  images: [ProductsConnectionImages]
  clean_product: [ProductsConnectionClean_product]
  company: [ProductsConnectionCompany]
  energy_kapseln: [ProductsConnectionEnergy_kapseln]
  kapseln: [ProductsConnectionKapseln]
  for_sale_count: [ProductsConnectionFor_sale_count]
  unit: [ProductsConnectionUnit]
  discount: [ProductsConnectionDiscount]
  type_test: [ProductsConnectionType_test]
  published_at: [ProductsConnectionPublished_at]
}

type ProductsConnectionId {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionCreated_at {
  key: DateTime
  connection: ProductsConnection
}

type ProductsConnectionUpdated_at {
  key: DateTime
  connection: ProductsConnection
}

type ProductsConnectionPrice {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionImages {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionClean_product {
  key: Boolean
  connection: ProductsConnection
}

type ProductsConnectionCompany {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionEnergy_kapseln {
  key: Boolean
  connection: ProductsConnection
}

type ProductsConnectionKapseln {
  key: Boolean
  connection: ProductsConnection
}

type ProductsConnectionFor_sale_count {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionUnit {
  key: String
  connection: ProductsConnection
}

type ProductsConnectionDiscount {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionType_test {
  key: ID
  connection: ProductsConnection
}

type ProductsConnectionPublished_at {
  key: DateTime
  connection: ProductsConnection
}

input ProductInput {
  price: String
  images: ID
  clean_product: Boolean
  company: String
  energy_kapseln: Boolean
  kapseln: Boolean
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductInput {
  price: String
  images: ID
  clean_product: Boolean
  company: String
  energy_kapseln: Boolean
  kapseln: Boolean
  for_sale_count: Long
  unit: String
  discount: Long
  type_test: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductInput {
  data: ProductInput
}

type createProductPayload {
  product: Products
}

input updateProductInput {
  where: InputID
  data: editProductInput
}

type updateProductPayload {
  product: Products
}

input deleteProductInput {
  where: InputID
}

type deleteProductPayload {
  product: Products
}

type Reinigung {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Bodylotion(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Seife(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type ReinigungConnection {
  values: [Reinigung]
  groupBy: ReinigungGroupBy
  aggregate: ReinigungAggregator
}

type ReinigungAggregator {
  count: Int
  totalCount: Int
}

type ReinigungGroupBy {
  id: [ReinigungConnectionId]
  created_at: [ReinigungConnectionCreated_at]
  updated_at: [ReinigungConnectionUpdated_at]
  published_at: [ReinigungConnectionPublished_at]
}

type ReinigungConnectionId {
  key: ID
  connection: ReinigungConnection
}

type ReinigungConnectionCreated_at {
  key: DateTime
  connection: ReinigungConnection
}

type ReinigungConnectionUpdated_at {
  key: DateTime
  connection: ReinigungConnection
}

type ReinigungConnectionPublished_at {
  key: DateTime
  connection: ReinigungConnection
}

input ReinigungInput {
  Bodylotion: [ID]
  Seife: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editReinigungInput {
  Bodylotion: [ID]
  Seife: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createReinigungInput {
  data: ReinigungInput
}

type createReinigungPayload {
  reinigung: Reinigung
}

input updateReinigungInput {
  where: InputID
  data: editReinigungInput
}

type updateReinigungPayload {
  reinigung: Reinigung
}

input deleteReinigungInput {
  where: InputID
}

type deleteReinigungPayload {
  reinigung: Reinigung
}

type ShampooConditioner {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Shampoo(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Conditioner(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type ShampooConditionerConnection {
  values: [ShampooConditioner]
  groupBy: ShampooConditionerGroupBy
  aggregate: ShampooConditionerAggregator
}

type ShampooConditionerAggregator {
  count: Int
  totalCount: Int
}

type ShampooConditionerGroupBy {
  id: [ShampooConditionerConnectionId]
  created_at: [ShampooConditionerConnectionCreated_at]
  updated_at: [ShampooConditionerConnectionUpdated_at]
  published_at: [ShampooConditionerConnectionPublished_at]
}

type ShampooConditionerConnectionId {
  key: ID
  connection: ShampooConditionerConnection
}

type ShampooConditionerConnectionCreated_at {
  key: DateTime
  connection: ShampooConditionerConnection
}

type ShampooConditionerConnectionUpdated_at {
  key: DateTime
  connection: ShampooConditionerConnection
}

type ShampooConditionerConnectionPublished_at {
  key: DateTime
  connection: ShampooConditionerConnection
}

input ShampooConditionerInput {
  Shampoo: [ID]
  Conditioner: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShampooConditionerInput {
  Shampoo: [ID]
  Conditioner: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShampooConditionerInput {
  data: ShampooConditionerInput
}

type createShampooConditionerPayload {
  shampooConditioner: ShampooConditioner
}

input updateShampooConditionerInput {
  where: InputID
  data: editShampooConditionerInput
}

type updateShampooConditionerPayload {
  shampooConditioner: ShampooConditioner
}

input deleteShampooConditionerInput {
  where: InputID
}

type deleteShampooConditionerPayload {
  shampooConditioner: ShampooConditioner
}

type ShoppingBasket {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  users_permissions_user: UsersPermissionsUser
  product: Products
  quantity: Long
  published_at: DateTime
}

type ShoppingBasketConnection {
  values: [ShoppingBasket]
  groupBy: ShoppingBasketGroupBy
  aggregate: ShoppingBasketAggregator
}

type ShoppingBasketAggregator {
  count: Int
  totalCount: Int
}

type ShoppingBasketGroupBy {
  id: [ShoppingBasketConnectionId]
  created_at: [ShoppingBasketConnectionCreated_at]
  updated_at: [ShoppingBasketConnectionUpdated_at]
  users_permissions_user: [ShoppingBasketConnectionUsers_permissions_user]
  product: [ShoppingBasketConnectionProduct]
  quantity: [ShoppingBasketConnectionQuantity]
  published_at: [ShoppingBasketConnectionPublished_at]
}

type ShoppingBasketConnectionId {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionCreated_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionUpdated_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionUsers_permissions_user {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionProduct {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionQuantity {
  key: ID
  connection: ShoppingBasketConnection
}

type ShoppingBasketConnectionPublished_at {
  key: DateTime
  connection: ShoppingBasketConnection
}

input ShoppingBasketInput {
  users_permissions_user: ID
  product: ID
  quantity: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editShoppingBasketInput {
  users_permissions_user: ID
  product: ID
  quantity: Long
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createShoppingBasketInput {
  data: ShoppingBasketInput
}

type createShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

input updateShoppingBasketInput {
  where: InputID
  data: editShoppingBasketInput
}

type updateShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

input deleteShoppingBasketInput {
  where: InputID
}

type deleteShoppingBasketPayload {
  shoppingBasket: ShoppingBasket
}

type Spezialpflege {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  LoremIpsum(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type SpezialpflegeConnection {
  values: [Spezialpflege]
  groupBy: SpezialpflegeGroupBy
  aggregate: SpezialpflegeAggregator
}

type SpezialpflegeAggregator {
  count: Int
  totalCount: Int
}

type SpezialpflegeGroupBy {
  id: [SpezialpflegeConnectionId]
  created_at: [SpezialpflegeConnectionCreated_at]
  updated_at: [SpezialpflegeConnectionUpdated_at]
  published_at: [SpezialpflegeConnectionPublished_at]
}

type SpezialpflegeConnectionId {
  key: ID
  connection: SpezialpflegeConnection
}

type SpezialpflegeConnectionCreated_at {
  key: DateTime
  connection: SpezialpflegeConnection
}

type SpezialpflegeConnectionUpdated_at {
  key: DateTime
  connection: SpezialpflegeConnection
}

type SpezialpflegeConnectionPublished_at {
  key: DateTime
  connection: SpezialpflegeConnection
}

input SpezialpflegeInput {
  LoremIpsum: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editSpezialpflegeInput {
  LoremIpsum: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createSpezialpflegeInput {
  data: SpezialpflegeInput
}

type createSpezialpflegePayload {
  spezialpflege: Spezialpflege
}

input updateSpezialpflegeInput {
  where: InputID
  data: editSpezialpflegeInput
}

type updateSpezialpflegePayload {
  spezialpflege: Spezialpflege
}

input deleteSpezialpflegeInput {
  where: InputID
}

type deleteSpezialpflegePayload {
  spezialpflege: Spezialpflege
}

type Styling {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  published_at: DateTime
  Haarspray(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Pomade(sort: String, limit: Int, start: Int, where: JSON): [Products]
  Saltspray(sort: String, limit: Int, start: Int, where: JSON): [Products]
}

type StylingConnection {
  values: [Styling]
  groupBy: StylingGroupBy
  aggregate: StylingAggregator
}

type StylingAggregator {
  count: Int
  totalCount: Int
}

type StylingGroupBy {
  id: [StylingConnectionId]
  created_at: [StylingConnectionCreated_at]
  updated_at: [StylingConnectionUpdated_at]
  published_at: [StylingConnectionPublished_at]
}

type StylingConnectionId {
  key: ID
  connection: StylingConnection
}

type StylingConnectionCreated_at {
  key: DateTime
  connection: StylingConnection
}

type StylingConnectionUpdated_at {
  key: DateTime
  connection: StylingConnection
}

type StylingConnectionPublished_at {
  key: DateTime
  connection: StylingConnection
}

input StylingInput {
  Haarspray: [ID]
  Pomade: [ID]
  Saltspray: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editStylingInput {
  Haarspray: [ID]
  Pomade: [ID]
  Saltspray: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createStylingInput {
  data: StylingInput
}

type createStylingPayload {
  styling: Styling
}

input updateStylingInput {
  where: InputID
  data: editStylingInput
}

type updateStylingPayload {
  styling: Styling
}

input deleteStylingInput {
  where: InputID
}

type deleteStylingPayload {
  styling: Styling
}

type TypeTest {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  brand: String
  price: Float
  size: Long
  quantity: Long
  images: UploadFile
  published_at: DateTime
}

type TypeTestConnection {
  values: [TypeTest]
  groupBy: TypeTestGroupBy
  aggregate: TypeTestAggregator
}

type TypeTestAggregator {
  count: Int
  totalCount: Int
  sum: TypeTestAggregatorSum
  avg: TypeTestAggregatorAvg
  min: TypeTestAggregatorMin
  max: TypeTestAggregatorMax
}

type TypeTestAggregatorSum {
  price: Float
}

type TypeTestAggregatorAvg {
  price: Float
}

type TypeTestAggregatorMin {
  price: Float
}

type TypeTestAggregatorMax {
  price: Float
}

type TypeTestGroupBy {
  id: [TypeTestConnectionId]
  created_at: [TypeTestConnectionCreated_at]
  updated_at: [TypeTestConnectionUpdated_at]
  brand: [TypeTestConnectionBrand]
  price: [TypeTestConnectionPrice]
  size: [TypeTestConnectionSize]
  quantity: [TypeTestConnectionQuantity]
  images: [TypeTestConnectionImages]
  published_at: [TypeTestConnectionPublished_at]
}

type TypeTestConnectionId {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionCreated_at {
  key: DateTime
  connection: TypeTestConnection
}

type TypeTestConnectionUpdated_at {
  key: DateTime
  connection: TypeTestConnection
}

type TypeTestConnectionBrand {
  key: String
  connection: TypeTestConnection
}

type TypeTestConnectionPrice {
  key: Float
  connection: TypeTestConnection
}

type TypeTestConnectionSize {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionQuantity {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionImages {
  key: ID
  connection: TypeTestConnection
}

type TypeTestConnectionPublished_at {
  key: DateTime
  connection: TypeTestConnection
}

input TypeTestInput {
  brand: String
  price: Float
  size: Long
  quantity: Long
  images: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTypeTestInput {
  brand: String
  price: Float
  size: Long
  quantity: Long
  images: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTypeTestInput {
  data: TypeTestInput
}

type createTypeTestPayload {
  typeTest: TypeTest
}

input updateTypeTestInput {
  where: InputID
  data: editTypeTestInput
}

type updateTypeTestPayload {
  typeTest: TypeTest
}

input deleteTypeTestInput {
  where: InputID
}

type deleteTypeTestPayload {
  typeTest: TypeTest
}

type Videos {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  video: UploadFile
  Review_Bioeffect: String
  video_name: String
  description: String
  published_at: DateTime
}

type VideosConnection {
  values: [Videos]
  groupBy: VideosGroupBy
  aggregate: VideosAggregator
}

type VideosAggregator {
  count: Int
  totalCount: Int
}

type VideosGroupBy {
  id: [VideosConnectionId]
  created_at: [VideosConnectionCreated_at]
  updated_at: [VideosConnectionUpdated_at]
  video: [VideosConnectionVideo]
  Review_Bioeffect: [VideosConnectionReview_Bioeffect]
  video_name: [VideosConnectionVideo_name]
  description: [VideosConnectionDescription]
  published_at: [VideosConnectionPublished_at]
}

type VideosConnectionId {
  key: ID
  connection: VideosConnection
}

type VideosConnectionCreated_at {
  key: DateTime
  connection: VideosConnection
}

type VideosConnectionUpdated_at {
  key: DateTime
  connection: VideosConnection
}

type VideosConnectionVideo {
  key: ID
  connection: VideosConnection
}

type VideosConnectionReview_Bioeffect {
  key: String
  connection: VideosConnection
}

type VideosConnectionVideo_name {
  key: String
  connection: VideosConnection
}

type VideosConnectionDescription {
  key: String
  connection: VideosConnection
}

type VideosConnectionPublished_at {
  key: DateTime
  connection: VideosConnection
}

input VideoInput {
  video: ID
  Review_Bioeffect: String
  video_name: String
  description: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVideoInput {
  video: ID
  Review_Bioeffect: String
  video_name: String
  description: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVideoInput {
  data: VideoInput
}

type createVideoPayload {
  video: Videos
}

input updateVideoInput {
  where: InputID
  data: editVideoInput
}

type updateVideoPayload {
  video: Videos
}

input deleteVideoInput {
  where: InputID
}

type deleteVideoPayload {
  video: Videos
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
  images(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  images: [ID]
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  images: [ID]
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | CleanBeauty | CleanBeautyConnection | CleanBeautyAggregator | CleanBeautyGroupBy | CleanBeautyConnectionId | CleanBeautyConnectionCreated_at | CleanBeautyConnectionUpdated_at | CleanBeautyConnectionPublished_at | createCleanBeautyPayload | updateCleanBeautyPayload | deleteCleanBeautyPayload | Discount | updateDiscountPayload | deleteDiscountPayload | FavoriteProduct | FavoriteProductConnection | FavoriteProductAggregator | FavoriteProductGroupBy | FavoriteProductConnectionId | FavoriteProductConnectionCreated_at | FavoriteProductConnectionUpdated_at | FavoriteProductConnectionUsers_permissions_user | FavoriteProductConnectionProduct | FavoriteProductConnectionPublished_at | createFavoriteProductPayload | updateFavoriteProductPayload | deleteFavoriteProductPayload | Gesicht | GesichtConnection | GesichtAggregator | GesichtGroupBy | GesichtConnectionId | GesichtConnectionCreated_at | GesichtConnectionUpdated_at | GesichtConnectionGesichtsreinigung | GesichtConnectionGesichtspflege | GesichtConnectionHautbedurfnis | GesichtConnectionPublished_at | createGesichtPayload | updateGesichtPayload | deleteGesichtPayload | Gesichtspflege | GesichtspflegeConnection | GesichtspflegeAggregator | GesichtspflegeGroupBy | GesichtspflegeConnectionId | GesichtspflegeConnectionCreated_at | GesichtspflegeConnectionUpdated_at | GesichtspflegeConnectionPublished_at | createGesichtspflegePayload | updateGesichtspflegePayload | deleteGesichtspflegePayload | Gesichtsreinigung | GesichtsreinigungConnection | GesichtsreinigungAggregator | GesichtsreinigungGroupBy | GesichtsreinigungConnectionId | GesichtsreinigungConnectionCreated_at | GesichtsreinigungConnectionUpdated_at | GesichtsreinigungConnectionPublished_at | createGesichtsreinigungPayload | updateGesichtsreinigungPayload | deleteGesichtsreinigungPayload | Haarbedurfnis | HaarbedurfnisConnection | HaarbedurfnisAggregator | HaarbedurfnisGroupBy | HaarbedurfnisConnectionId | HaarbedurfnisConnectionCreated_at | HaarbedurfnisConnectionUpdated_at | HaarbedurfnisConnectionPublished_at | createHaarbedurfniPayload | updateHaarbedurfniPayload | deleteHaarbedurfniPayload | Haare | HaareConnection | HaareAggregator | HaareGroupBy | HaareConnectionId | HaareConnectionCreated_at | HaareConnectionUpdated_at | HaareConnectionShampoo_conditioner | HaareConnectionIntensivpflege | HaareConnectionStyling | HaareConnectionHaarbedurfni | HaareConnectionSpezialpflege | HaareConnectionPublished_at | createHaarePayload | updateHaarePayload | deleteHaarePayload | HandeFusse | HandeFusseConnection | HandeFusseAggregator | HandeFusseGroupBy | HandeFusseConnectionId | HandeFusseConnectionCreated_at | HandeFusseConnectionUpdated_at | HandeFusseConnectionPublished_at | createHandeFussePayload | updateHandeFussePayload | deleteHandeFussePayload | Hautbedurfnis | HautbedurfnisConnection | HautbedurfnisAggregator | HautbedurfnisGroupBy | HautbedurfnisConnectionId | HautbedurfnisConnectionCreated_at | HautbedurfnisConnectionUpdated_at | HautbedurfnisConnectionPublished_at | createHautbedurfniPayload | updateHautbedurfniPayload | deleteHautbedurfniPayload | Herren | HerrenConnection | HerrenAggregator | HerrenGroupBy | HerrenConnectionId | HerrenConnectionCreated_at | HerrenConnectionUpdated_at | HerrenConnectionPublished_at | createHerrenPayload | updateHerrenPayload | deleteHerrenPayload | HomePageAdvertising | HomePageAdvertisingConnection | HomePageAdvertisingAggregator | HomePageAdvertisingGroupBy | HomePageAdvertisingConnectionId | HomePageAdvertisingConnectionCreated_at | HomePageAdvertisingConnectionUpdated_at | HomePageAdvertisingConnectionName | HomePageAdvertisingConnectionDescription | HomePageAdvertisingConnectionAdvertising | HomePageAdvertisingConnectionOnImageAdvertising | HomePageAdvertisingConnectionOnImageText | HomePageAdvertisingConnectionPublished_at | createHomePageAdvertisingPayload | updateHomePageAdvertisingPayload | deleteHomePageAdvertisingPayload | Intensivpflege | IntensivpflegeConnection | IntensivpflegeAggregator | IntensivpflegeGroupBy | IntensivpflegeConnectionId | IntensivpflegeConnectionCreated_at | IntensivpflegeConnectionUpdated_at | IntensivpflegeConnectionPublished_at | createIntensivpflegePayload | updateIntensivpflegePayload | deleteIntensivpflegePayload | Korper | KorperConnection | KorperAggregator | KorperGroupBy | KorperConnectionId | KorperConnectionCreated_at | KorperConnectionUpdated_at | KorperConnectionReinigung | KorperConnectionKorperpflege | KorperConnectionHande_fusse | KorperConnectionPublished_at | createKorperPayload | updateKorperPayload | deleteKorperPayload | Korperpflege | KorperpflegeConnection | KorperpflegeAggregator | KorperpflegeGroupBy | KorperpflegeConnectionId | KorperpflegeConnectionCreated_at | KorperpflegeConnectionUpdated_at | KorperpflegeConnectionPublished_at | createKorperpflegePayload | updateKorperpflegePayload | deleteKorperpflegePayload | Livestyle | LivestyleConnection | LivestyleAggregator | LivestyleGroupBy | LivestyleConnectionId | LivestyleConnectionCreated_at | LivestyleConnectionUpdated_at | LivestyleConnectionPublished_at | createLivestylePayload | updateLivestylePayload | deleteLivestylePayload | Navbar | NavbarConnection | NavbarAggregator | NavbarGroupBy | NavbarConnectionId | NavbarConnectionCreated_at | NavbarConnectionUpdated_at | NavbarConnectionCategories | NavbarConnectionPublished_at | createNavbarPayload | updateNavbarPayload | deleteNavbarPayload | PageHeader | PageHeaderConnection | PageHeaderAggregator | PageHeaderGroupBy | PageHeaderConnectionId | PageHeaderConnectionCreated_at | PageHeaderConnectionUpdated_at | PageHeaderConnectionInfo | PageHeaderConnectionPage_headers_style | PageHeaderConnectionPublished_at | createPageHeaderPayload | updatePageHeaderPayload | deletePageHeaderPayload | Parfums | ParfumsConnection | ParfumsAggregator | ParfumsGroupBy | ParfumsConnectionId | ParfumsConnectionCreated_at | ParfumsConnectionUpdated_at | ParfumsConnectionPublished_at | createParfumPayload | updateParfumPayload | deleteParfumPayload | Products | ProductsConnection | ProductsAggregator | ProductsGroupBy | ProductsConnectionId | ProductsConnectionCreated_at | ProductsConnectionUpdated_at | ProductsConnectionPrice | ProductsConnectionImages | ProductsConnectionClean_product | ProductsConnectionCompany | ProductsConnectionEnergy_kapseln | ProductsConnectionKapseln | ProductsConnectionFor_sale_count | ProductsConnectionUnit | ProductsConnectionDiscount | ProductsConnectionType_test | ProductsConnectionPublished_at | createProductPayload | updateProductPayload | deleteProductPayload | Reinigung | ReinigungConnection | ReinigungAggregator | ReinigungGroupBy | ReinigungConnectionId | ReinigungConnectionCreated_at | ReinigungConnectionUpdated_at | ReinigungConnectionPublished_at | createReinigungPayload | updateReinigungPayload | deleteReinigungPayload | ShampooConditioner | ShampooConditionerConnection | ShampooConditionerAggregator | ShampooConditionerGroupBy | ShampooConditionerConnectionId | ShampooConditionerConnectionCreated_at | ShampooConditionerConnectionUpdated_at | ShampooConditionerConnectionPublished_at | createShampooConditionerPayload | updateShampooConditionerPayload | deleteShampooConditionerPayload | ShoppingBasket | ShoppingBasketConnection | ShoppingBasketAggregator | ShoppingBasketGroupBy | ShoppingBasketConnectionId | ShoppingBasketConnectionCreated_at | ShoppingBasketConnectionUpdated_at | ShoppingBasketConnectionUsers_permissions_user | ShoppingBasketConnectionProduct | ShoppingBasketConnectionQuantity | ShoppingBasketConnectionPublished_at | createShoppingBasketPayload | updateShoppingBasketPayload | deleteShoppingBasketPayload | Spezialpflege | SpezialpflegeConnection | SpezialpflegeAggregator | SpezialpflegeGroupBy | SpezialpflegeConnectionId | SpezialpflegeConnectionCreated_at | SpezialpflegeConnectionUpdated_at | SpezialpflegeConnectionPublished_at | createSpezialpflegePayload | updateSpezialpflegePayload | deleteSpezialpflegePayload | Styling | StylingConnection | StylingAggregator | StylingGroupBy | StylingConnectionId | StylingConnectionCreated_at | StylingConnectionUpdated_at | StylingConnectionPublished_at | createStylingPayload | updateStylingPayload | deleteStylingPayload | TypeTest | TypeTestConnection | TypeTestAggregator | TypeTestAggregatorSum | TypeTestAggregatorAvg | TypeTestAggregatorMin | TypeTestAggregatorMax | TypeTestGroupBy | TypeTestConnectionId | TypeTestConnectionCreated_at | TypeTestConnectionUpdated_at | TypeTestConnectionBrand | TypeTestConnectionPrice | TypeTestConnectionSize | TypeTestConnectionQuantity | TypeTestConnectionImages | TypeTestConnectionPublished_at | createTypeTestPayload | updateTypeTestPayload | deleteTypeTestPayload | Videos | VideosConnection | VideosAggregator | VideosGroupBy | VideosConnectionId | VideosConnectionCreated_at | VideosConnectionUpdated_at | VideosConnectionVideo | VideosConnectionReview_Bioeffect | VideosConnectionVideo_name | VideosConnectionDescription | VideosConnectionPublished_at | createVideoPayload | updateVideoPayload | deleteVideoPayload | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  cleanBeauty(id: ID!, publicationState: PublicationState): CleanBeauty
  cleanBeauties(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [CleanBeauty]
  cleanBeautiesConnection(sort: String, limit: Int, start: Int, where: JSON): CleanBeautyConnection
  discount(publicationState: PublicationState): Discount
  favoriteProduct(id: ID!, publicationState: PublicationState): FavoriteProduct
  favoriteProducts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [FavoriteProduct]
  favoriteProductsConnection(sort: String, limit: Int, start: Int, where: JSON): FavoriteProductConnection
  gesicht(id: ID!, publicationState: PublicationState): Gesicht
  gesichts(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Gesicht]
  gesichtsConnection(sort: String, limit: Int, start: Int, where: JSON): GesichtConnection
  gesichtspflege(id: ID!, publicationState: PublicationState): Gesichtspflege
  gesichtspfleges(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Gesichtspflege]
  gesichtspflegesConnection(sort: String, limit: Int, start: Int, where: JSON): GesichtspflegeConnection
  gesichtsreinigung(id: ID!, publicationState: PublicationState): Gesichtsreinigung
  gesichtsreinigungs(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Gesichtsreinigung]
  gesichtsreinigungsConnection(sort: String, limit: Int, start: Int, where: JSON): GesichtsreinigungConnection
  haarbedurfni(id: ID!, publicationState: PublicationState): Haarbedurfnis
  haarbedurfnis(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Haarbedurfnis]
  haarbedurfnisConnection(sort: String, limit: Int, start: Int, where: JSON): HaarbedurfnisConnection
  haare(id: ID!, publicationState: PublicationState): Haare
  haares(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Haare]
  haaresConnection(sort: String, limit: Int, start: Int, where: JSON): HaareConnection
  handeFusse(id: ID!, publicationState: PublicationState): HandeFusse
  handeFusses(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [HandeFusse]
  handeFussesConnection(sort: String, limit: Int, start: Int, where: JSON): HandeFusseConnection
  hautbedurfni(id: ID!, publicationState: PublicationState): Hautbedurfnis
  hautbedurfnis(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Hautbedurfnis]
  hautbedurfnisConnection(sort: String, limit: Int, start: Int, where: JSON): HautbedurfnisConnection
  herren(id: ID!, publicationState: PublicationState): Herren
  herrens(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Herren]
  herrensConnection(sort: String, limit: Int, start: Int, where: JSON): HerrenConnection
  homePageAdvertising(id: ID!, publicationState: PublicationState): HomePageAdvertising
  homePageAdvertisings(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [HomePageAdvertising]
  homePageAdvertisingsConnection(sort: String, limit: Int, start: Int, where: JSON): HomePageAdvertisingConnection
  intensivpflege(id: ID!, publicationState: PublicationState): Intensivpflege
  intensivpfleges(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Intensivpflege]
  intensivpflegesConnection(sort: String, limit: Int, start: Int, where: JSON): IntensivpflegeConnection
  korper(id: ID!, publicationState: PublicationState): Korper
  korpers(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Korper]
  korpersConnection(sort: String, limit: Int, start: Int, where: JSON): KorperConnection
  korperpflege(id: ID!, publicationState: PublicationState): Korperpflege
  korperpfleges(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Korperpflege]
  korperpflegesConnection(sort: String, limit: Int, start: Int, where: JSON): KorperpflegeConnection
  livestyle(id: ID!, publicationState: PublicationState): Livestyle
  livestyles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Livestyle]
  livestylesConnection(sort: String, limit: Int, start: Int, where: JSON): LivestyleConnection
  navbar(id: ID!, publicationState: PublicationState): Navbar
  navbars(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Navbar]
  navbarsConnection(sort: String, limit: Int, start: Int, where: JSON): NavbarConnection
  pageHeader(id: ID!, publicationState: PublicationState): PageHeader
  pageHeaders(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [PageHeader]
  pageHeadersConnection(sort: String, limit: Int, start: Int, where: JSON): PageHeaderConnection
  parfum(id: ID!, publicationState: PublicationState): Parfums
  parfums(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Parfums]
  parfumsConnection(sort: String, limit: Int, start: Int, where: JSON): ParfumsConnection
  product(id: ID!, publicationState: PublicationState): Products
  products(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Products]
  productsConnection(sort: String, limit: Int, start: Int, where: JSON): ProductsConnection
  reinigung(id: ID!, publicationState: PublicationState): Reinigung
  reinigungs(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Reinigung]
  reinigungsConnection(sort: String, limit: Int, start: Int, where: JSON): ReinigungConnection
  shampooConditioner(id: ID!, publicationState: PublicationState): ShampooConditioner
  shampooConditioners(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShampooConditioner]
  shampooConditionersConnection(sort: String, limit: Int, start: Int, where: JSON): ShampooConditionerConnection
  shoppingBasket(id: ID!, publicationState: PublicationState): ShoppingBasket
  shoppingBaskets(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ShoppingBasket]
  shoppingBasketsConnection(sort: String, limit: Int, start: Int, where: JSON): ShoppingBasketConnection
  spezialpflege(id: ID!, publicationState: PublicationState): Spezialpflege
  spezialpfleges(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Spezialpflege]
  spezialpflegesConnection(sort: String, limit: Int, start: Int, where: JSON): SpezialpflegeConnection
  styling(id: ID!, publicationState: PublicationState): Styling
  stylings(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Styling]
  stylingsConnection(sort: String, limit: Int, start: Int, where: JSON): StylingConnection
  typeTest(id: ID!, publicationState: PublicationState): TypeTest
  typeTests(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [TypeTest]
  typeTestsConnection(sort: String, limit: Int, start: Int, where: JSON): TypeTestConnection
  video(id: ID!, publicationState: PublicationState): Videos
  videos(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Videos]
  videosConnection(sort: String, limit: Int, start: Int, where: JSON): VideosConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createCleanBeauty(input: createCleanBeautyInput): createCleanBeautyPayload
  updateCleanBeauty(input: updateCleanBeautyInput): updateCleanBeautyPayload
  deleteCleanBeauty(input: deleteCleanBeautyInput): deleteCleanBeautyPayload
  updateDiscount(input: updateDiscountInput): updateDiscountPayload
  deleteDiscount: deleteDiscountPayload
  createFavoriteProduct(input: createFavoriteProductInput): createFavoriteProductPayload
  updateFavoriteProduct(input: updateFavoriteProductInput): updateFavoriteProductPayload
  deleteFavoriteProduct(input: deleteFavoriteProductInput): deleteFavoriteProductPayload
  createGesicht(input: createGesichtInput): createGesichtPayload
  updateGesicht(input: updateGesichtInput): updateGesichtPayload
  deleteGesicht(input: deleteGesichtInput): deleteGesichtPayload
  createGesichtspflege(input: createGesichtspflegeInput): createGesichtspflegePayload
  updateGesichtspflege(input: updateGesichtspflegeInput): updateGesichtspflegePayload
  deleteGesichtspflege(input: deleteGesichtspflegeInput): deleteGesichtspflegePayload
  createGesichtsreinigung(input: createGesichtsreinigungInput): createGesichtsreinigungPayload
  updateGesichtsreinigung(input: updateGesichtsreinigungInput): updateGesichtsreinigungPayload
  deleteGesichtsreinigung(input: deleteGesichtsreinigungInput): deleteGesichtsreinigungPayload
  createHaarbedurfni(input: createHaarbedurfniInput): createHaarbedurfniPayload
  updateHaarbedurfni(input: updateHaarbedurfniInput): updateHaarbedurfniPayload
  deleteHaarbedurfni(input: deleteHaarbedurfniInput): deleteHaarbedurfniPayload
  createHaare(input: createHaareInput): createHaarePayload
  updateHaare(input: updateHaareInput): updateHaarePayload
  deleteHaare(input: deleteHaareInput): deleteHaarePayload
  createHandeFusse(input: createHandeFusseInput): createHandeFussePayload
  updateHandeFusse(input: updateHandeFusseInput): updateHandeFussePayload
  deleteHandeFusse(input: deleteHandeFusseInput): deleteHandeFussePayload
  createHautbedurfni(input: createHautbedurfniInput): createHautbedurfniPayload
  updateHautbedurfni(input: updateHautbedurfniInput): updateHautbedurfniPayload
  deleteHautbedurfni(input: deleteHautbedurfniInput): deleteHautbedurfniPayload
  createHerren(input: createHerrenInput): createHerrenPayload
  updateHerren(input: updateHerrenInput): updateHerrenPayload
  deleteHerren(input: deleteHerrenInput): deleteHerrenPayload
  createHomePageAdvertising(input: createHomePageAdvertisingInput): createHomePageAdvertisingPayload
  updateHomePageAdvertising(input: updateHomePageAdvertisingInput): updateHomePageAdvertisingPayload
  deleteHomePageAdvertising(input: deleteHomePageAdvertisingInput): deleteHomePageAdvertisingPayload
  createIntensivpflege(input: createIntensivpflegeInput): createIntensivpflegePayload
  updateIntensivpflege(input: updateIntensivpflegeInput): updateIntensivpflegePayload
  deleteIntensivpflege(input: deleteIntensivpflegeInput): deleteIntensivpflegePayload
  createKorper(input: createKorperInput): createKorperPayload
  updateKorper(input: updateKorperInput): updateKorperPayload
  deleteKorper(input: deleteKorperInput): deleteKorperPayload
  createKorperpflege(input: createKorperpflegeInput): createKorperpflegePayload
  updateKorperpflege(input: updateKorperpflegeInput): updateKorperpflegePayload
  deleteKorperpflege(input: deleteKorperpflegeInput): deleteKorperpflegePayload
  createLivestyle(input: createLivestyleInput): createLivestylePayload
  updateLivestyle(input: updateLivestyleInput): updateLivestylePayload
  deleteLivestyle(input: deleteLivestyleInput): deleteLivestylePayload
  createNavbar(input: createNavbarInput): createNavbarPayload
  updateNavbar(input: updateNavbarInput): updateNavbarPayload
  deleteNavbar(input: deleteNavbarInput): deleteNavbarPayload
  createPageHeader(input: createPageHeaderInput): createPageHeaderPayload
  updatePageHeader(input: updatePageHeaderInput): updatePageHeaderPayload
  deletePageHeader(input: deletePageHeaderInput): deletePageHeaderPayload
  createParfum(input: createParfumInput): createParfumPayload
  updateParfum(input: updateParfumInput): updateParfumPayload
  deleteParfum(input: deleteParfumInput): deleteParfumPayload
  createProduct(input: createProductInput): createProductPayload
  updateProduct(input: updateProductInput): updateProductPayload
  deleteProduct(input: deleteProductInput): deleteProductPayload
  createReinigung(input: createReinigungInput): createReinigungPayload
  updateReinigung(input: updateReinigungInput): updateReinigungPayload
  deleteReinigung(input: deleteReinigungInput): deleteReinigungPayload
  createShampooConditioner(input: createShampooConditionerInput): createShampooConditionerPayload
  updateShampooConditioner(input: updateShampooConditionerInput): updateShampooConditionerPayload
  deleteShampooConditioner(input: deleteShampooConditionerInput): deleteShampooConditionerPayload
  createShoppingBasket(input: createShoppingBasketInput): createShoppingBasketPayload
  updateShoppingBasket(input: updateShoppingBasketInput): updateShoppingBasketPayload
  deleteShoppingBasket(input: deleteShoppingBasketInput): deleteShoppingBasketPayload
  createSpezialpflege(input: createSpezialpflegeInput): createSpezialpflegePayload
  updateSpezialpflege(input: updateSpezialpflegeInput): updateSpezialpflegePayload
  deleteSpezialpflege(input: deleteSpezialpflegeInput): deleteSpezialpflegePayload
  createStyling(input: createStylingInput): createStylingPayload
  updateStyling(input: updateStylingInput): updateStylingPayload
  deleteStyling(input: deleteStylingInput): deleteStylingPayload
  createTypeTest(input: createTypeTestInput): createTypeTestPayload
  updateTypeTest(input: updateTypeTestInput): updateTypeTestPayload
  deleteTypeTest(input: deleteTypeTestInput): deleteTypeTestPayload
  createVideo(input: createVideoInput): createVideoPayload
  updateVideo(input: updateVideoInput): updateVideoPayload
  deleteVideo(input: deleteVideoInput): deleteVideoPayload

  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
